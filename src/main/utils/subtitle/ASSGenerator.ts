import type { ASSStyle, ASSOptions, SRTSubtitle } from '../../../shared/types/subtitle.types';
import * as fs from 'fs-extra';

/**
 * ASS字幕生成器
 * 用于生成ASS格式的字幕文件
 */
export class ASSGenerator {
  private styles: ASSStyle[];
  private options: ASSOptions;

  constructor(styles: ASSStyle[], options: ASSOptions) {
    this.styles = styles;
    this.options = options;
  }

  /**
   * 生成ASS文件内容
   * @param subtitles 字幕数组
   * @param defaultStyle 默认样式名称
   * @returns ASS文件内容
   */
  generate(subtitles: SRTSubtitle[], defaultStyle: string): string {
    let content = '';
    
    // 1. Script Info 部分
    content += this.generateScriptInfo();
    content += '\n';
    
    // 2. V4+ Styles 部分
    content += this.generateStyles();
    content += '\n';
    
    // 3. Events 部分
    content += this.generateEvents(subtitles, defaultStyle);
    
    return content;
  }

  /**
   * 生成Script Info部分
   */
  private generateScriptInfo(): string {
    return `[Script Info]
Title: Generated by VideoTool
ScriptType: ${this.options.scriptType}
WrapStyle: ${this.options.wrapStyle}
PlayResX: ${this.options.resolution.width}
PlayResY: ${this.options.resolution.height}
ScaledBorderAndShadow: ${this.options.scaledBorderAndShadow ? 'yes' : 'no'}
`;
  }

  /**
   * 生成V4+ Styles部分
   */
  private generateStyles(): string {
    let content = '[V4+ Styles]\n';
    content += 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding, LineSpacing\n';
    
    for (const style of this.styles) {
      content += this.formatStyle(style);
    }
    
    return content;
  }

  /**
   * 格式化单个样式
   */
  private formatStyle(style: ASSStyle): string {
    return `Style: ${style.name},${style.fontname},${style.fontsize},${style.primaryColour},${style.secondaryColour},${style.outlineColour},${style.backColour},${style.bold},${style.italic},${style.underline},${style.strikeOut},${style.scaleX},${style.scaleY},${style.spacing},${style.angle},${style.borderStyle},${style.outline},${style.shadow},${style.alignment},${style.marginL},${style.marginR},${style.marginV},${style.encoding},${style.lineSpacing}\n`;
  }

  /**
   * 生成Events部分
   */
  private generateEvents(subtitles: SRTSubtitle[], defaultStyle: string): string {
    let content = '[Events]\n';
    content += 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n';
    
    for (const subtitle of subtitles) {
      const start = this.convertTimeFormat(subtitle.startTime);
      const end = this.convertTimeFormat(subtitle.endTime);
      const text = this.escapeText(subtitle.text);
      
      content += `Dialogue: 0,${start},${end},${defaultStyle},,0,0,0,,${text}\n`;
    }
    
    return content;
  }

  /**
   * 转换时间格式
   * 从 "00:00:00,000" 转换为 "0:00:00.00"
   */
  private convertTimeFormat(srtTime: string): string {
    const parts = srtTime.split(',');
    const time = parts[0];
    const ms = parts[1];
    
    // 移除小时前导零，保留两位毫秒
    const timeParts = time.split(':');
    const hours = parseInt(timeParts[0], 10);
    const minutes = timeParts[1];
    const seconds = timeParts[2];
    const centiseconds = ms.substring(0, 2);
    
    return `${hours}:${minutes}:${seconds}.${centiseconds}`;
  }

  /**
   * 转义文本
   */
  private escapeText(text: string): string {
    // 将 \n 替换为 ASS 的换行符 \N
    return text.replace(/\n/g, '\\N');
  }

  /**
   * 添加样式
   */
  addStyle(style: ASSStyle): void {
    this.styles.push(style);
  }

  /**
   * 移除样式
   */
  removeStyle(styleName: string): void {
    this.styles = this.styles.filter((s) => s.name !== styleName);
  }

  /**
   * 获取所有样式
   */
  getStyles(): ASSStyle[] {
    return [...this.styles];
  }

  /**
   * 从文件解析样式
   */
  parseStylesFromFile(filePath: string): ASSStyle[] {
    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const styles: ASSStyle[] = [];
      
      // 查找 [V4+ Styles] 部分
      const stylesSection = content.match(/\[V4\+ Styles\]([\s\S]*?)(?:\n\[|$)/);
      if (!stylesSection) return styles;
      
      const lines = stylesSection[1].split('\n');
      
      for (const line of lines) {
        if (line.startsWith('Style:')) {
          const parts = line.substring(6).split(',').map((s) => s.trim());
          
          if (parts.length >= 23) {
            styles.push({
              name: parts[0],
              fontname: parts[1],
              fontsize: parseInt(parts[2], 10),
              primaryColour: parts[3],
              secondaryColour: parts[4],
              outlineColour: parts[5],
              backColour: parts[6],
              bold: parseInt(parts[7], 10),
              italic: parseInt(parts[8], 10),
              underline: parseInt(parts[9], 10),
              strikeOut: parseInt(parts[10], 10),
              scaleX: parseInt(parts[11], 10),
              scaleY: parseInt(parts[12], 10),
              spacing: parseFloat(parts[13]),
              angle: parseFloat(parts[14]),
              borderStyle: parseInt(parts[15], 10),
              outline: parseFloat(parts[16]),
              shadow: parseFloat(parts[17]),
              alignment: parseInt(parts[18], 10),
              marginL: parseInt(parts[19], 10),
              marginR: parseInt(parts[20], 10),
              marginV: parseInt(parts[21], 10),
              encoding: parseInt(parts[22], 10),
              lineSpacing: parts[23] ? parseFloat(parts[23]) : 0,
            });
          }
        }
      }
      
      return styles;
    } catch (error) {
      console.error('Error parsing styles from file:', error);
      return [];
    }
  }
}


/**
 * 浏览器端字幕转换工具
 * 不依赖Node.js模块，纯前端实现
 */

import defaultRules from '../../shared/presets/subtitle-convert/regex-rules.json';

interface RegexRule {
  id: string;
  name: string;
  pattern: string;
  replacement: string;
  description: string;
  enabled: boolean;
  order: number;
}

interface SRTSubtitle {
  index: number;
  startTime: string;
  endTime: string;
  text: string;
}

/**
 * 应用正则替换规则
 */
export function applyRegexRules(text: string, rules: RegexRule[]): string {
  let result = text;
  
  const enabledRules = rules
    .filter((r) => r.enabled)
    .sort((a, b) => a.order - b.order);

  for (const rule of enabledRules) {
    try {
      const regex = new RegExp(rule.pattern, 'gm');
      result = result.replace(regex, rule.replacement);
    } catch (error) {
      console.error(`Error applying rule ${rule.name}:`, error);
    }
  }

  return result;
}

/**
 * 解析SRT字幕
 */
export function parseSRT(content: string): SRTSubtitle[] {
  const subtitles: SRTSubtitle[] = [];
  
  content = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const blocks = content.split(/\n\n+/);
  
  for (const block of blocks) {
    const lines = block.trim().split('\n');
    
    if (lines.length < 3) continue;
    
    try {
      const index = parseInt(lines[0], 10);
      const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
      
      if (!timeMatch) continue;
      
      const startTime = timeMatch[1];
      const endTime = timeMatch[2];
      const text = lines.slice(2).join('\n');
      
      subtitles.push({ index, startTime, endTime, text });
    } catch (error) {
      console.error('Error parsing subtitle block:', error);
    }
  }
  
  return subtitles;
}

/**
 * 生成ASS字幕
 */
export function generateASS(subtitles: SRTSubtitle[], styleName: string = '译文字幕 底部'): string {
  let content = '';
  
  // Script Info
  content += `[Script Info]
Title: Generated by VideoTool
ScriptType: v4.00+
Collisions: Normal
WrapStyle: 0
PlayResX: 384
PlayResY: 288
ScaledBorderAndShadow: no
Synch Point: 1

`;

  // V4+ Styles
  content += `[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding, LineSpacing
Style: 译文字幕 底部,Microsoft YaHei,18,&H00FFFFFF,&H00535353,&H00000000,&H00000000,1,0,0,0,100,100,1,0,1,0.5,0,2,5,5,18,1,1
Style: 双语 原文,微软雅黑,14,&H00FFFFFF,&H004E4E4E,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0.5,0,2,5,5,18,1,0
Style: 双语 译文,Microsoft YaHei,18,&H00FFFFFF,&H004E4E4E,&H00000000,&H00000000,1,0,0,0,100,100,1,0,1,0.5,0,2,5,5,18,1,0

`;

  // Events
  content += `[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  for (const subtitle of subtitles) {
    const start = convertTimeFormat(subtitle.startTime);
    const end = convertTimeFormat(subtitle.endTime);
    const text = subtitle.text.replace(/\n/g, '\\N');
    
    content += `Dialogue: 0,${start},${end},${styleName},,0,0,0,,${text}\n`;
  }
  
  return content;
}

/**
 * 转换时间格式
 */
function convertTimeFormat(srtTime: string): string {
  const parts = srtTime.split(',');
  const time = parts[0];
  const ms = parts[1];
  
  const timeParts = time.split(':');
  const hours = parseInt(timeParts[0], 10);
  const minutes = timeParts[1];
  const seconds = timeParts[2];
  const centiseconds = ms.substring(0, 2);
  
  return `${hours}:${minutes}:${seconds}.${centiseconds}`;
}

/**
 * 获取默认正则规则
 */
export function getDefaultRegexRules(): RegexRule[] {
  return (defaultRules as any).rules || [];
}

/**
 * 获取可用样式列表
 */
export function getAvailableStyles(): string[] {
  return [
    '译文字幕 底部',
    '双语 原文',
    '双语 译文',
  ];
}


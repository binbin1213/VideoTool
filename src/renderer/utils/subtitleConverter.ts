/**
 * 浏览器端字幕转换工具
 * 不依赖Node.js模块，纯前端实现
 */

import defaultRules from '../../shared/presets/subtitle-convert/regex-rules.json';
import template1080p from '../../assets/subtitle-styles.template.ass?raw';
import template4k from '../../assets/subtitle-styles.template.4k.ass?raw';
import { parseASSTemplate, parseASSResolution } from './assStyleParser';

interface RegexRule {
  id: string;
  name: string;
  pattern: string;
  replacement: string;
  description: string;
  enabled: boolean;
  order: number;
}

interface SRTSubtitle {
  index: number;
  startTime: string;
  endTime: string;
  text: string;
}

// 通用字幕接口（用于格式转换）
export interface Subtitle {
  index: number;
  startTime: string; // 统一格式: HH:MM:SS.mmm
  endTime: string;   // 统一格式: HH:MM:SS.mmm
  text: string;
}

export type SubtitleFormat = 'srt' | 'ass' | 'vtt';

interface ASSStyleParams {
  name: string;
  fontname: string;
  fontsize: number;
  primaryColour: string;      // &H00BBGGRR 格式
  secondaryColour: string;
  outlineColour: string;
  backColour: string;
  bold: 0 | 1;
  italic: 0 | 1;
  underline: 0 | 1;
  strikeOut: 0 | 1;
  scaleX: number;
  scaleY: number;
  spacing: number;
  angle: number;
  borderStyle: 1 | 3;
  outline: number;
  shadow: number;
  alignment: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
  marginL: number;
  marginR: number;
  marginV: number;
  encoding: number;
  lineSpacing: number;
}

/**
 * 应用正则替换规则
 */
export function applyRegexRules(text: string, rules: RegexRule[]): string {
  let result = text;
  
  const enabledRules = rules
    .filter((r) => r.enabled)
    .sort((a, b) => a.order - b.order);

  for (const rule of enabledRules) {
    try {
      const regex = new RegExp(rule.pattern, 'gm');
      result = result.replace(regex, rule.replacement);
    } catch (error) {
      console.error(`Error applying rule ${rule.name}:`, error);
    }
  }

  return result;
}

/**
 * 自动为注释文本添加ASS样式覆盖标签
 * @param text 字幕文本
 * @param videoHeight 视频高度（用于确定字号）
 * @returns 处理后的文本
 */
export function applyAnnotationStyles(text: string, videoHeight?: number): string {
  // 匹配（注：xxx）格式的注释
  // 支持中文括号和英文括号
  const annotationPattern = /([（(]注[：:][^）)]+[）)])/g;
  
  // 根据分辨率确定注释字号
  // 4K (2160p) = 110, 1080p = 55
  const annotationFontSize = videoHeight && videoHeight >= 2000 ? 110 : 55;
  
  // 注释样式覆盖标签
  // \fs = 字号
  // \i1 = 斜体
  // \c&HCCCCCC& = 浅灰色
  const styleOverride = `{\\fs${annotationFontSize}\\i1\\c&HCCCCCC&}`;
  const resetTag = '{\\r}';
  
  let result = text;
  
  // 检查是否包含注释
  if (annotationPattern.test(text)) {
    // 重置正则状态
    annotationPattern.lastIndex = 0;
    
    result = text.replace(annotationPattern, (match, _p1, offset) => {
      // 检查注释后是否还有内容（排除空白字符）
      const afterMatch = text.substring(offset + match.length).trim();
      const hasContentAfter = afterMatch.length > 0;
      
      // 只在注释后还有内容时才添加重置标签
      if (hasContentAfter) {
        return `${styleOverride}${match}${resetTag}`;
      } else {
        // 注释在末尾，不需要重置标签
        return `${styleOverride}${match}`;
      }
    });
  }
  
  return result;
}

/**
 * 解析SRT字幕
 */
export function parseSRT(content: string): SRTSubtitle[] {
  const subtitles: SRTSubtitle[] = [];
  
  // 移除 BOM 和统一换行符
  content = content.replace(/^\uFEFF/, '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const blocks = content.split(/\n\n+/);
  
  for (const block of blocks) {
    const lines = block.trim().split('\n');
    
    if (lines.length < 3) continue;
    
    try {
      const index = parseInt(lines[0], 10);
      const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
      
      if (!timeMatch) continue;
      
      const startTime = timeMatch[1];
      const endTime = timeMatch[2];
      const text = lines.slice(2).join('\n');
      
      subtitles.push({ index, startTime, endTime, text });
    } catch (error) {
      console.error('Error parsing subtitle block:', error);
    }
  }
  
  return subtitles;
}

/**
 * 生成ASS字幕（支持自定义样式参数和自动分辨率适配）
 * @param subtitles 字幕数组
 * @param styleName 样式名称
 * @param watermark 水印配置（可选）
 * @param customStyleParams 自定义样式参数（可选）
 * @param videoHeight 视频高度（像素，可选）- 用于自动选择 1080p/4K 模板
 * @returns UTF-8 编码的 ASS 格式字幕内容
 */
export function generateASS(
  subtitles: SRTSubtitle[], 
  styleName: string = '电影字幕 底部', // 使用模板中的默认样式 ✅
  watermark?: { text: string; position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' },
  customStyleParams?: ASSStyleParams,
  videoHeight?: number
): string {
  let content = '';
  
  // 根据视频高度自动选择模板
  const { styles: selectedStyles, resolution: selectedResolution } = selectTemplateByResolution(videoHeight);
  
  // Script Info (使用选中的分辨率)
  content += `[Script Info]
Title: Generated by VideoTool
ScriptType: v4.00+
Collisions: Normal
WrapStyle: 0
PlayResX: ${selectedResolution.width}
PlayResY: ${selectedResolution.height}
ScaledBorderAndShadow: no
Synch Point: 1

`;

  // V4+ Styles
  content += `[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding, LineSpacing
`;

  // 添加使用的样式（优先使用自定义参数）
  if (customStyleParams) {
    content += styleParamsToString(customStyleParams) + '\n';
  } else {
    // 从选中的模板中获取样式
    const style = selectedStyles[styleName] || selectedStyles['电影字幕 底部']; // 使用模板中的默认样式 ✅
    if (style) {
      content += styleParamsToString(style) + '\n';
    } else {
      // 降级：使用默认 1080p 样式
      const defaultStyle = PRESET_STYLES['电影字幕 底部']; // 使用模板中的默认样式 ✅
      content += styleParamsToString(defaultStyle) + '\n';
    }
  }
  
  // 添加水印样式
  content += `Style: 水印,Microsoft YaHei,10,&H32FFFFFF,&H00000000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,7,5,5,5,1,0
`;

  // Events
  content += `[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  // 添加水印（如果启用）
  if (watermark && watermark.text && subtitles.length > 0) {
    const firstStart = convertTimeFormat(subtitles[0].startTime);
    const lastEnd = convertTimeFormat(subtitles[subtitles.length - 1].endTime);
    
    // 根据位置设置对齐方式和边距
    let alignment = 7; // 默认顶部居中
    let marginL = 5;
    let marginR = 5;
    let marginV = 5;
    
    switch (watermark.position) {
      case 'top-left':
        alignment = 7; // 顶部左对齐
        marginL = 10;
        marginV = 10;
        break;
      case 'top-right':
        alignment = 9; // 顶部右对齐
        marginR = 10;
        marginV = 10;
        break;
      case 'bottom-left':
        alignment = 1; // 底部左对齐
        marginL = 10;
        marginV = 30;
        break;
      case 'bottom-right':
        alignment = 3; // 底部右对齐
        marginR = 10;
        marginV = 30;
        break;
    }
    
    // 使用特殊的样式覆盖标签来设置水印样式（半透明、小字体）
    const watermarkText = `{\\an${alignment}\\fs10\\alpha&H80&}${watermark.text}`;
    content += `Comment: 0,${firstStart},${lastEnd},水印,,${marginL},${marginR},${marginV},,${watermarkText}\n`;
  }

  // 添加字幕内容
  for (const subtitle of subtitles) {
    const start = convertTimeFormat(subtitle.startTime);
    const end = convertTimeFormat(subtitle.endTime);
    
    // 1. 转换换行符
    let text = subtitle.text.replace(/\n/g, '\\N');
    
    // 2. 自动处理注释样式（传入视频高度以适配分辨率）
    text = applyAnnotationStyles(text, videoHeight);
    
    content += `Dialogue: 0,${start},${end},${styleName},,0,0,0,,${text}\n`;
  }
  
  return content;
}

/**
 * 转换时间格式
 */
function convertTimeFormat(srtTime: string): string {
  const parts = srtTime.split(',');
  const time = parts[0];
  const ms = parts[1];
  
  const timeParts = time.split(':');
  const hours = parseInt(timeParts[0], 10);
  const minutes = timeParts[1];
  const seconds = timeParts[2];
  const msNum = Number(ms);
  const centiseconds = String(Math.floor(msNum / 10)).padStart(2, '0');
  
  return `${hours}:${minutes}:${seconds}.${centiseconds}`;
}

/**
 * 获取默认正则规则
 */
export function getDefaultRegexRules(): RegexRule[] {
  return (defaultRules as any).rules || [];
}

// ============================================
// 从模板文件解析预设样式（单一数据源）
// ============================================

// 解析 1080p 模板
const PRESET_STYLES_1080P = parseASSTemplate(template1080p);
const RESOLUTION_1080P = parseASSResolution(template1080p);

// 解析 4K 模板
const PRESET_STYLES_4K = parseASSTemplate(template4k);
const RESOLUTION_4K = parseASSResolution(template4k);

/**
 * 根据视频高度自动选择合适的样式模板
 * @param videoHeight 视频高度（像素），可选
 * @returns 样式集合和分辨率信息
 */
function selectTemplateByResolution(videoHeight?: number): {
  styles: Record<string, ASSStyleParams>;
  resolution: { width: number; height: number };
} {
  // 如果没有提供视频高度，默认使用 1080p
  if (!videoHeight) {
    return {
      styles: PRESET_STYLES_1080P,
      resolution: RESOLUTION_1080P
    };
  }
  
  // 根据视频高度自动选择模板
  // 2000 作为分界点（接近 1080p 的 1.85 倍）
  if (videoHeight >= 2000) {
    // 4K (2160p) 或更高分辨率
    return {
      styles: PRESET_STYLES_4K,
      resolution: RESOLUTION_4K
    };
  } else {
    // 1080p (1080p) 或更低分辨率
    return {
      styles: PRESET_STYLES_1080P,
      resolution: RESOLUTION_1080P
    };
  }
}

// 默认使用 1080p 样式（向后兼容）
const PRESET_STYLES = PRESET_STYLES_1080P;

// 导出模板选择函数和样式供外部使用
export { PRESET_STYLES_4K, RESOLUTION_4K, RESOLUTION_1080P, selectTemplateByResolution };

/**
 * 导出类型
 */
export type { ASSStyleParams };

/**
 * 获取预设样式
 */
export function getPresetStyle(name: string): ASSStyleParams | undefined {
  return PRESET_STYLES[name];
}

/**
 * 获取所有预设样式名称
 */
export function getPresetStyleNames(): string[] {
  return Object.keys(PRESET_STYLES);
}

/**
 * 获取可用样式列表（包含自定义样式）
 */
export function getAvailableStyles(): string[] {
  const customStyles = getCustomStyles();
  return [...Object.keys(PRESET_STYLES), ...customStyles.map(s => s.name)];
}

/**
 * 保存自定义样式到localStorage
 */
export function saveCustomStyle(style: ASSStyleParams): void {
  const customStyles = getCustomStyles();
  const existingIndex = customStyles.findIndex(s => s.name === style.name);
  
  if (existingIndex >= 0) {
    customStyles[existingIndex] = style;
  } else {
    customStyles.push(style);
  }
  
  localStorage.setItem('custom_ass_styles', JSON.stringify(customStyles));
}

/**
 * 获取自定义样式列表
 */
export function getCustomStyles(): ASSStyleParams[] {
  try {
    const saved = localStorage.getItem('custom_ass_styles');
    return saved ? JSON.parse(saved) : [];
  } catch {
    return [];
  }
}

/**
 * 删除自定义样式
 */
export function deleteCustomStyle(name: string): void {
  const customStyles = getCustomStyles().filter(s => s.name !== name);
  localStorage.setItem('custom_ass_styles', JSON.stringify(customStyles));
}

/**
 * 获取样式参数（预设或自定义）
 */
export function getStyleParams(name: string): ASSStyleParams | undefined {
  // 先查预设
  const preset = PRESET_STYLES[name];
  if (preset) return preset;
  
  // 再查自定义
  const customStyles = getCustomStyles();
  return customStyles.find(s => s.name === name);
}

/**
 * 样式参数转换为ASS格式字符串
 */
export function styleParamsToString(style: ASSStyleParams): string {
  return `Style: ${style.name},${style.fontname},${style.fontsize},${style.primaryColour},${style.secondaryColour},${style.outlineColour},${style.backColour},${style.bold},${style.italic},${style.underline},${style.strikeOut},${style.scaleX},${style.scaleY},${style.spacing},${style.angle},${style.borderStyle},${style.outline},${style.shadow},${style.alignment},${style.marginL},${style.marginR},${style.marginV},${style.encoding},${style.lineSpacing}`;
}

// ========================================
// 多格式支持：VTT 和 ASS 解析/生成
// ========================================

/**
 * 解析 VTT 字幕文件
 */
export function parseVTT(content: string): Subtitle[] {
  const subtitles: Subtitle[] = [];
  
  // 移除 BOM 和统一换行符
  content = content.replace(/^\uFEFF/, '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  
  // 移除 WEBVTT 头部和样式/注释块
  const lines = content.split('\n');
  let inCueBlock = false;
  let currentCue: {index: number; time?: string; text: string[]} = {index: 0, text: []};
  let cueIndex = 1;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // 跳过 WEBVTT 头部
    if (line.startsWith('WEBVTT') || line.startsWith('NOTE') || line.startsWith('STYLE')) {
      continue;
    }
    
    // 检测时间行 (HH:MM:SS.mmm --> HH:MM:SS.mmm)
    const timeMatch = line.match(/^(\d{2}:\d{2}:\d{2}\.\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}\.\d{3})/);
    
    if (timeMatch) {
      // 保存上一个 cue
      if (currentCue.time && currentCue.text.length > 0) {
        const [startTime, endTime] = currentCue.time.split(' --> ');
        subtitles.push({
          index: currentCue.index,
          startTime: startTime.trim(),
          endTime: endTime.trim(),
          text: currentCue.text.join('\n')
        });
      }
      
      // 开始新的 cue
      currentCue = {
        index: cueIndex++,
        time: line,
        text: []
      };
      inCueBlock = true;
    } else if (line === '' && inCueBlock) {
      // 空行表示 cue 结束
      if (currentCue.time && currentCue.text.length > 0) {
        const [startTime, endTime] = currentCue.time.split(' --> ');
        subtitles.push({
          index: currentCue.index,
          startTime: startTime.trim(),
          endTime: endTime.trim(),
          text: currentCue.text.join('\n')
        });
        currentCue = {index: 0, text: []};
      }
      inCueBlock = false;
    } else if (inCueBlock && line !== '' && !line.match(/^\d+$/)) {
      // cue 文本内容（跳过可能的 cue 标识符数字）
      currentCue.text.push(line);
    }
  }
  
  // 处理最后一个 cue
  if (currentCue.time && currentCue.text.length > 0) {
    const [startTime, endTime] = currentCue.time.split(' --> ');
    subtitles.push({
      index: currentCue.index,
      startTime: startTime.trim(),
      endTime: endTime.trim(),
      text: currentCue.text.join('\n')
    });
  }
  
  return subtitles;
}

/**
 * 解析 ASS 字幕文件（提取纯文本）
 */
export function parseASS(content: string): Subtitle[] {
  const subtitles: Subtitle[] = [];
  
  // 移除 BOM 和统一换行符
  content = content.replace(/^\uFEFF/, '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  
  const lines = content.split('\n');
  let inEvents = false;
  let index = 1;
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    // 检测 Events 部分
    if (trimmed === '[Events]') {
      inEvents = true;
      continue;
    }
    
    // 如果进入新的部分，退出 Events
    if (trimmed.startsWith('[') && trimmed !== '[Events]') {
      inEvents = false;
      continue;
    }
    
    // 解析 Dialogue 行
    if (inEvents && trimmed.startsWith('Dialogue:')) {
      try {
        // 格式: Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text
        const parts = trimmed.substring(9).split(','); // 去掉 "Dialogue:"
        
        if (parts.length >= 10) {
          const startTime = parts[1].trim();
          const endTime = parts[2].trim();
          const text = parts.slice(9).join(',').trim(); // Text 可能包含逗号
          
          // 移除 ASS 样式标签 (如 {\xxx})
          const cleanText = text.replace(/\{[^}]*\}/g, '');
          
          if (cleanText) {
            subtitles.push({
              index: index++,
              startTime: convertASSTimeToStandard(startTime),
              endTime: convertASSTimeToStandard(endTime),
              text: cleanText
            });
          }
        }
      } catch (error) {
        console.error('Error parsing ASS dialogue line:', error);
      }
    }
  }
  
  return subtitles;
}

/**
 * 生成 VTT 字幕文件
 * @returns UTF-8 编码的 VTT 内容
 */
export function generateVTT(subtitles: Subtitle[]): string {
  let content = 'WEBVTT\n\n';
  
  for (const sub of subtitles) {
    content += `${sub.index}\n`;
    content += `${sub.startTime} --> ${sub.endTime}\n`;
    content += `${sub.text}\n\n`;
  }
  
  return content;
}

/**
 * 生成 SRT 字幕文件
 * @returns UTF-8 编码的 SRT 内容
 */
export function generateSRT(subtitles: Subtitle[]): string {
  let content = '';
  
  for (const sub of subtitles) {
    // 将时间格式转换为 SRT 格式 (HH:MM:SS,mmm)
    const startTime = sub.startTime.replace('.', ',');
    const endTime = sub.endTime.replace('.', ',');
    
    content += `${sub.index}\n`;
    content += `${startTime} --> ${endTime}\n`;
    content += `${sub.text}\n\n`;
  }
  
  return content;
}

/**
 * ASS 时间格式转标准格式
 * ASS: H:MM:SS.CC (小时可能是一位数，厘秒两位)
 * 标准: HH:MM:SS.mmm
 */
function convertASSTimeToStandard(assTime: string): string {
  const match = assTime.match(/^(\d{1,2}):(\d{2}):(\d{2})\.(\d{2})$/);
  if (!match) return assTime;
  
  const hours = match[1].padStart(2, '0');
  const minutes = match[2];
  const seconds = match[3];
  const centiseconds = match[4];
  const milliseconds = (parseInt(centiseconds) * 10).toString().padStart(3, '0');
  
  return `${hours}:${minutes}:${seconds}.${milliseconds}`;
}

/**
 * 统一字幕转换函数
 * @param content 输入字幕内容（UTF-8 编码）
 * @param inputFormat 输入格式
 * @param outputFormat 输出格式
 * @param options 转换选项（用于输出 ASS）
 * @returns UTF-8 编码的输出字幕内容
 */
export function convertSubtitle(
  content: string,
  inputFormat: SubtitleFormat,
  outputFormat: SubtitleFormat,
  options?: {
    styleName?: string;
    watermark?: { text: string; position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' };
    customStyleParams?: ASSStyleParams;
    videoHeight?: number;
    regexRules?: RegexRule[];
    applyRegex?: boolean;
  }
): string {
  // 1. 解析输入格式到通用格式
  let subtitles: Subtitle[];
  
  switch (inputFormat) {
    case 'srt': {
      const srtSubs = parseSRT(content);
      subtitles = srtSubs.map(s => ({
        index: s.index,
        startTime: s.startTime.replace(',', '.'), // SRT 使用逗号，转为点
        endTime: s.endTime.replace(',', '.'),
        text: s.text
      }));
      break;
    }
    case 'vtt':
      subtitles = parseVTT(content);
      break;
    case 'ass':
      subtitles = parseASS(content);
      break;
    default:
      throw new Error(`Unsupported input format: ${inputFormat}`);
  }
  
  // 2. 应用正则规则（如果启用且提供）
  if (options?.applyRegex && options?.regexRules) {
    subtitles = subtitles.map(sub => ({
      ...sub,
      text: applyRegexRules(sub.text, options.regexRules!)
    }));
  }
  
  // 3. 转换为输出格式
  switch (outputFormat) {
    case 'srt':
      return generateSRT(subtitles);
    case 'vtt':
      return generateVTT(subtitles);
    case 'ass': {
      // 转换为 SRTSubtitle 格式（generateASS 需要）
      const srtSubs: SRTSubtitle[] = subtitles.map(s => ({
        index: s.index,
        startTime: s.startTime.replace('.', ','), // ASS 生成函数内部处理时间格式
        endTime: s.endTime.replace('.', ','),
        text: options?.videoHeight ? applyAnnotationStyles(s.text, options.videoHeight) : s.text
      }));
      
      return generateASS(
        srtSubs,
        options?.styleName || '电影字幕 底部',
        options?.watermark,
        options?.customStyleParams,
        options?.videoHeight
      );
    }
    default:
      throw new Error(`Unsupported output format: ${outputFormat}`);
  }
}

